---
title: "Task 5 Appendex - Quick demo with cFOS Controller"
weight: 3
---

### Purpose

In this chapter, we going to setup a end to end demo to secure traffic from internet to application deployed in aks cluster. we will use aks loadBalancer SVC to create loadbalancer svc to backend application.

**traffic diagram without use cFOS**

![direct](../images/direct.png)

**traffic diagram after use cFOS in the middle**

with cFOS in the middle, it function as a reverse proxy. 
![proxyed](../images/trafficcfos.png)


### Quick Demo

With cFOS license and cFOS image pull secret ready, we are ready to do a quick demo. 
in this demo, we will create a loadBalancer svc for backend web application, then we deploy a cfos controller, this cfos controller will deploy a cFOS and then create a reverse proxy with VIP on CFOS to pretect http traffic ingress to this web application, the cFOS configuration will be done by cFOS controller automatically, in Chapter 6, you will do same but without rely on cFOS controller. 


**create cfos controller** 
{{% notice style="info" %}}
please be aware the cfos controller is only for demo purpose, this is NOT A PRODUCT from fortinet. it is build for this demo only. 
{{% /notice %}}

the cfos controller use below preconfigred variable 
```
  cfosContainerImage: "fortinetwandy.azurecr.io/cfos:255"
  cfosImagePullSecret: "cfosimagepullsecret"
  managedByController: "fortinetcfos"
  cfosNameSpace: "cfostest"
```
if you use different cfosContainerImage repo or namespace etc, make sure modify 04_deploy_cfos_controller.yaml to match with actual variable before deploy cfoscontroller.

```bash
cd $HOME
kubectl  apply -f $scriptDir/k8s-201-workshop/scripts/cfos/04_deploy_cfos_controller.yaml
```
**create backend application and clusterip SVC**
```bash
kubectl create deployment goweb --image=interbeing/myfmg:fileuploadserverx86
kubectl expose  deployment goweb --target-port=80  --port=80
```
**create loadBalancer SVC** 

Below yaml file will create a loadbalancer SVC, this service will exposed TCP port 8888 to internet via azure LB,the target endpoint will be cfos container on tcp port 8888 based on selector **app: cfos** and **targetPort** field in spec , then cFOS controller will config CFOS with cFOS POD IP + 8888 as VIP and map to actual application goweb clusterIP+tcp port 80. goweb application can in any namespace like belew use namespace default. 

The traffic path will be 
client(1)---Internet--azure LB public IP/DNS(2) ---cFOS VIP+PORT(3) ---goweb cluster ip:port(4) --goweb POD IP:PORT(5)

- (1) client can be azure cloud shell or your laptop browser 
- (2) DNS name will be $svcname.$location.cloudapp.azure.com
- (3) cFOS port1 IP + VIP PORT 8888
- (4) goweb cluster ip for example 10.96.240.247:80 
- (5) goweb POD IP + PORT for example 10.224.0.19:80

```bash
cd $HOME
svcname=$(kubectl config view -o json | jq .clusters[0].cluster.server | cut -d "." -f 1 | cut -d "/" -f 3)
metallbip=$(kubectl get ipaddresspool -n metallb-system -o jsonpath='{.items[*].spec.addresses[0]}' | cut -d '/' -f 1)
echo use pool ipaddress $metallbip for svc 
cat << EOF | tee > 03_single.yaml 
apiVersion: v1
kind: Service
metadata:
  name: cfos7210250-service
  annotations:
    managedByController: fortinetcfos
    metallb.universe.tf/loadBalancerIPs: $metallbip
    service.beta.kubernetes.io/azure-dns-label-name: $svcname
spec:
  sessionAffinity: ClientIP
  ports:
  - port: 8888
    name: cfos-goweb-default-1
    targetPort: 8888
    protocol: TCP
  selector:
    app: cfos
  type: LoadBalancer

EOF
kubectl apply -f 03_single.yaml  -n $cfosnamespace
kubectl rollout status deployment cfos7210250-deployment -n $cfosnamespace
sleep 5
kubectl get svc cfos7210250-service  -n $cfosnamespace 
```

### Verify Result
```

curl http://$svcname.$location.cloudapp.azure.com:8888

```
you shall see output 
```
<html><body><form enctype="multipart/form-data" action="/upload" method="post">
<input type="file" name="myFile" />
<input type="submit" value="Upload" />
```

### Clean up 
```bash
cd $HOME
kubectl delete namespace $cfosnamespace
kubectl delete -f $scriptDir/k8s-201-workshop/scripts/cfos/04_deploy_cfos_controller.yaml
kubectl delete sa sa-cfoscontrolleramd64alpha16
kubectl delete deployment goweb
kubectl delete svc goweb
#az aks delete --name ${aksClusterName} -g ${resourceGroupName}
```
### Q&A

**Question**
What is the benefit of using cFOS to pretect ingress traffic compare with use Fortigate OS VM or appliance ?


**Answer**

- K8s Native 

with cFOS controller, end-user even does not require any knowledge of network or fortios cli. end-user only require create or modify existing loadBalancer SVC yaml file and deploy them use kubectl. that's ALL.


- secure POD to POD traffic and VM to POD traffic.
FortiGate VM/appliance can not protect traffic within VNET if Fortigate deployed outside of VNET.
but with cFOS, you can easiy secure traffic between POD to POD and VM to POD without introduce other component. 

